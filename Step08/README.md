# Step08 메모리 구조와 동적 메모리 할당

> 리눅스에서 하나의 실행 프로그램(Process) 는 5개의 영역을 가짐

## 프로세스의 메모리 구조

> 리눅스와 같은 운영체제가 메모리 보호와 효율적인 자원 관리를 하기 위해 만들어진 구조

|영역 | 설명|
|----|-----|
| **Text** | 코드가 저장된 영역 (기계어, 읽기 전용) |
| **Data** | 초기화된 전역/정적 변수 저장 영역 |
| **BSS** | 초기화되지 않은 전역/정적 변수 저장 영역 |
| **Heap** | 실행 중 동적으로 할당되는 메모리 영역 (`malloc` 등) |
| **Stack** | 함수 호출 시 생성되는 지역 변수 및 함수 프레임 저장 영역|

## 리눅스와 메모리의 관계

- 리눅스는 **가상 메모리** 기반으로 프로세스마다 독립된 메모리 공간을 제공

- 커널은 각 프로세스의 **Heap** , **Stack** , **Text** 등의 영역을 관리하며, 시스템 콜을 통해 메모리를 할당/해제함

- `malloc` , `free` 등을 통해 **Heap** 영역을 조절할 수 있음

## 동적 메모리 할당 (`malloc` , `free`) 실습

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int* arr = (int*)malloc(sizeof(int) * 5); // 5개 int 공간 동적 할당

    if (arr == NULL) {
        printf("메모리 할당 실패\n");
        return 1;
    }

    for (int i = 0; i < 5; i++) {
        arr[i] = i * 10;
    }

    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }

    free(arr); // 동적 메모리 해제
    return 0;
}
```

- 동적 메모리 할당이 필요한 이유
   
   - 컴파일 시점에 크기를 알 수 없는 경우

   - 가변적인 데이터를 처리할 때 (ex : 사용자 입력, 파일 읽기 등)

   - 메모리의 효율적인 사용 (필요한 만큼만 사용하고 반환)


## 메모리 누수

> `malloc` 등으로 메모리를 할당한 후, `free` 하지 않으면 누적되어 사용하지 않는 메모리가 쌓이는 현상


- 메모리 누수는 장시간 실행되는 서버나 서비스에서 큰 문제가 될 수 있음

- `valgrind` 로 누수 확인하기

   ```
   valgrind ./test_malloc
   ```

   - `valgrind` : 리눅스에서 메모리 검사를 도와주는 tool , 누수가 발생하면 어떤 부분에서 free를 안 했는지까지 알려줌


